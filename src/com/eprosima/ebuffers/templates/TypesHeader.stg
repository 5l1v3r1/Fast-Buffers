group TypesHeader;

main(ctx, blocks) ::= <<
#ifndef _$ctx.filename$_H_
#define _$ctx.filename$_H_

#include <stdint.h>
#include <array>
#include <string>
#include <vector>

#if defined(WIN32)
#if defined(USER_CPP_DLL_EXPORT)
#define user_cpp_DllExport __declspec( dllexport )
#else
#define user_cpp_DllExport
#endif
#else
#define user_cpp_DllExport
#endif

$blocks; separator="\n"$

#endif // _$ctx.filename$_H_
>>

module(name, definition_list) ::= <<
namespace $name$
{
    $definition_list$
}
>>

definition_list(definitions) ::= <<
$definitions; separator="\n"$
>>

struct_type(ctx, struct) ::= <<
/*!
 * @brief This class represents the structure $struct.name$ defined by the user in the IDL file.
 */
class user_cpp_DllExport $struct.name$
{
public:
    $struct.name$();
    ~$struct.name$();
    $struct.name$(const $struct.name$ &x);
    $struct.name$($struct.name$ &&x);
    $struct.name$& operator=(const $struct.name$ &x);
    $struct.name$& operator=($struct.name$ &&x);
    
    $struct.members:{$public_structmember_declaration(it)$}; separator="\n"$
    
private:
    $struct.members:{$private_member_declaration(it)$}; separator="\n"$
};
>>

public_structmember_declaration(member) ::= <<
$if(member.typecode.primitive)$
inline void $member.name$($member.typecode.typename$ _$member.name$)
{
    m_$member.name$ = _$member.name$;
}

inline $member.typecode.typename$ $member.name$() const
{
    return m_$member.name$;
}

inline $member.typecode.typename$& $member.name$()
{
    return m_$member.name$;
}
$else$
inline void $member.name$(const $member.typecode.typename$ &_$member.name$)
{
    m_$member.name$ = _$member.name$;
}

inline void $member.name$($member.typecode.typename$ &&_$member.name$)
{
    m_$member.name$ = std::move(_$member.name$);
}

inline const $member.typecode.typename$& $member.name$() const
{
    return m_$member.name$;
}

inline $member.typecode.typename$& $member.name$()
{
    return m_$member.name$;
}
$endif$
>>

private_member_declaration(member) ::= <<$private_declaration(typecode=member.typecode, name=member.name)$>>

public_member_declaration(member) ::= <<$public_declaration(typecode=member.typecode, name=member.name)$>>

public_declaration(typecode, name) ::= <<
$if(typecode.primitive)$
void $name$($typecode.typename$ _$name$);
$typecode.typename$ $name$() const;
$typecode.typename$& $name$();
$else$
void $name$(const $typecode.typename$ &_$name$);
void $name$($typecode.typename$ &&_$name$);
const $typecode.typename$& $name$() const;
$typecode.typename$& $name$();
$endif$
>>

private_declaration(typecode, name) ::= <<
$typecode.typename$ m_$name$;
>>

union_type(ctx, union) ::= <<
/*!
 * @brief This class represents the union $union.name$ defined by the user in the IDL file.
 */
class user_cpp_DllExport $union.name$
{
public:
    $union.name$();
    ~$union.name$();
    $union.name$(const $union.name$ &x);
    $union.name$($union.name$ &&x);
    $union.name$& operator=(const $union.name$ &x);
    $union.name$& operator=($union.name$ &&x);
    
    $public_declaration(typecode=union.discriminator, name="_d")$
    
    $union.members:{$public_member_declaration(it)$}; separator="\n"$
    
private:
    $private_declaration(typecode=union.discriminator, name="_d")$
    
    $union.members:{$private_member_declaration(it)$}; separator="\n"$
};
>>

enum_type(ctx, enum) ::= <<
/*!
 * @brief This class represents the enumeration $enum.name$ defined by the user in the IDL file.
 */
enum $enum.name$ : uint32_t
{
    $enum.members:{$it.name$}; separator=",\n"$
};
>>