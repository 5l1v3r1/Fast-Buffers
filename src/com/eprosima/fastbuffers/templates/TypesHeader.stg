group TypesHeader;

main(ctx, blocks) ::= <<
$fileHeader(file=[ctx.filename, ".h"], description=["This header file contains the declaration of the described types in the IDL file."])$

#ifndef _$ctx.filename$_H_
#define _$ctx.filename$_H_

#include <stdint.h>
#include <array>
#include <string>
#include <vector>

#if defined(WIN32)
#if defined(USER_CPP_DLL_EXPORT)
#define user_cpp_DllExport __declspec( dllexport )
#else
#define user_cpp_DllExport
#endif
#else
#define user_cpp_DllExport
#endif

$blocks; separator="\n"$

#endif // _$ctx.filename$_H_
>>

module(ctx, name, definition_list) ::= <<
namespace $name$
{
    $definition_list$
}
>>

definition_list(definitions) ::= <<
$definitions; separator="\n"$
>>

export_list(ctx, name, exports) ::= <<
$exports; separator="\n"$

>>

struct_type(ctx, struct) ::= <<
/*!
 * @brief This class represents the structure $struct.name$ defined by the user in the IDL file.
 * @ingroup $ctx.trimfilename$
 */
class user_cpp_DllExport $struct.name$
{
public:

    /*!
     * @brief Default constructor.
     */
    $struct.name$();
    
    /*!
     * @brief Default destructor.
     */
    ~$struct.name$();
    
    /*!
     * @brief Copy constructor.
     * @param x Reference to the object $struct.scopedname$ that will be copied.
     */
    $struct.name$(const $struct.name$ &x);
    
    /*!
     * @brief Move constructor.
     * @param x Reference to the object $struct.scopedname$ that will be copied.
     */
    $struct.name$($struct.name$ &&x);
    
    /*!
     * @brief Copy assignment.
     * @param x Reference to the object $struct.scopedname$ that will be copied.
     */
    $struct.name$& operator=(const $struct.name$ &x);
    
    /*!
     * @brief Move assignment.
     * @param x Reference to the object $struct.scopedname$ that will be copied.
     */
    $struct.name$& operator=($struct.name$ &&x);
    
    $struct.members:{$public_structmember_declaration(it)$}; separator="\n"$
    
    $size_functions(struct)$
    
private:
    $struct.members:{$private_member_declaration(it)$}; separator="\n"$
};
>>

public_structmember_declaration(member) ::= <<
$if(member.typecode.primitive)$
/*!
 * @brief This function sets a value in member $member.name$
 * @param _$member.name$ New value for member $member.name$
 */
inline void $member.name$($member.typecode.typename$ _$member.name$)
{
    m_$member.name$ = _$member.name$;
}

/*!
 * @brief This function returns the value of member $member.name$
 * @return Value of member $member.name$
 */
inline $member.typecode.typename$ $member.name$() const
{
    return m_$member.name$;
}

/*!
 * @brief This function returns a reference to member $member.name$
 * @return Reference to member $member.name$
 */
inline $member.typecode.typename$& $member.name$()
{
    return m_$member.name$;
}
$else$
/*!
 * @brief This function copies the value in member $member.name$
 * @param _$member.name$ New value to be copied in member $member.name$
 */
inline void $member.name$(const $member.typecode.typename$ &_$member.name$)
{
    m_$member.name$ = _$member.name$;
}

/*!
 * @brief This function moves the value in member $member.name$
 * @param _$member.name$ New value to be moved in member $member.name$
 */
inline void $member.name$($member.typecode.typename$ &&_$member.name$)
{
    m_$member.name$ = std::move(_$member.name$);
}

/*!
 * @brief This function returns a constant reference to member $member.name$
 * @return Constant reference to member $member.name$
 */
inline const $member.typecode.typename$& $member.name$() const
{
    return m_$member.name$;
}

/*!
 * @brief This function returns a reference to member $member.name$
 * @return Reference to member $member.name$
 */
inline $member.typecode.typename$& $member.name$()
{
    return m_$member.name$;
}
$endif$
>>

private_member_declaration(member) ::= <<$private_declaration(typecode=member.typecode, name=member.name)$>>

public_unionmember_declaration(member) ::= <<
$if(member.typecode.primitive)$
/*!
 * @brief This function sets a value in member $member.name$
 * @param _$member.name$ New value for member $member.name$
 */
void $member.name$($member.typecode.typename$ _$member.name$);

/*!
 * @brief This function returns the value of member $member.name$
 * @return Value of member $member.name$
 * @exception eprosima::BadParamException This exception is thrown if the requested union member is not the current selection.
 */
$member.typecode.typename$ $member.name$() const;

/*!
 * @brief This function returns a reference to member $member.name$
 * @return Reference to member $member.name$
 * @exception eprosima::BadParamException This exception is thrown if the requested union member is not the current selection.
 */
$member.typecode.typename$& $member.name$();
$else$
/*!
 * @brief This function copies the value in member $member.name$
 * @param _$member.name$ New value to be copied in member $member.name$
 */
void $member.name$(const $member.typecode.typename$ &_$member.name$);

/*!
 * @brief This function moves the value in member $member.name$
 * @param _$member.name$ New value to be moved in member $member.name$
 */
void $member.name$($member.typecode.typename$ &&_$member.name$);

/*!
 * @brief This function returns a constant reference to member $member.name$
 * @return Constant reference to member $member.name$
 * @exception eprosima::BadParamException This exception is thrown if the requested union member is not the current selection.
 */
const $member.typecode.typename$& $member.name$() const;

/*!
 * @brief This function returns a reference to member $member.name$
 * @return Reference to member $member.name$
 * @exception eprosima::BadParamException This exception is thrown if the requested union member is not the current selection.
 */
$member.typecode.typename$& $member.name$();
$endif$
>>

private_declaration(typecode, name) ::= <<
$typecode.typename$ m_$name$;
>>

union_type(ctx, union) ::= <<
/*!
 * @brief This class represents the union $union.name$ defined by the user in the IDL file.
 * @ingroup $ctx.trimfilename$
 */
class user_cpp_DllExport $union.name$
{
public:

    /*!
     * @brief Default constructor.
     */
    $union.name$();
    
    /*!
     * @brief Default destructor.
     */
    ~$union.name$();
    
    /*!
     * @brief Copy constructor.
     * @param x Reference to the object $union.scopedname$ that will be copied.
     */
    $union.name$(const $union.name$ &x);
    
    /*!
     * @brief Move constructor.
     * @param x Reference to the object $union.scopedname$ that will be copied.
     */
    $union.name$($union.name$ &&x);
    
    /*!
     * @brief Copy assignment.
     * @param x Reference to the object $union.scopedname$ that will be copied.
     */
    $union.name$& operator=(const $union.name$ &x);
    
    /*!
     * @brief Move assignment.
     * @param x Reference to the object $union.scopedname$ that will be copied.
     */
    $union.name$& operator=($union.name$ &&x);
    
    /*!
     * @brief This function sets the discriminator value.
     * @param __d New value for the discriminator.
     * @exception eprosima::BadParamException This exception is thrown if the new value doesn't correspond to the selected union member.
     */
    void _d($union.discriminator.typename$ __d);
    
    /*!
     * @brief This function returns the value of the discriminator.
     * @return Value of the discriminator
     */
    $union.discriminator.typename$ _d() const;
    
    /*!
     * @brief This function returns a reference to the discriminator.
     * @return Reference to the discriminator.
     */
    $union.discriminator.typename$& _d();
    
    $union.members:{$public_unionmember_declaration(it)$}; separator="\n"$
    
    $size_functions(union)$
    
private:
    $private_declaration(typecode=union.discriminator, name="_d")$
    
    $union.members:{$private_member_declaration(it)$}; separator="\n"$
};
>>

enum_type(ctx, enum) ::= <<
/*!
 * @brief This class represents the enumeration $enum.name$ defined by the user in the IDL file.
 * @ingroup $ctx.trimfilename$
 */
enum $enum.name$ : uint32_t
{
    $enum.members:{$it.name$}; separator=",\n"$
};
>>

size_functions(type) ::= <<
/*!
 * @brief This function calculates the space needed to serialize a type $type.scopedname$.
 *        For all types with a variable size (strings, sequences) and without a maximum limit, this function uses
 *        255 as maximum limit.
 */
 inline
 size_t getMaxSerializedSize() { return $type.maxSerializedSize$;}
 
 /*!
 * @brief This function calculates the space needed to serialize a type $type.scopedname$ without alignment.
 *        For all types with a variable size (strings, sequences) and without a maximum limit, this function uses
 *        255 as maximum limit.
 */
 inline
 size_t getMaxSerializedSizeWithoutAlign(){ return $type.maxSerializedSizeWithoutAlignment$;}
>>
